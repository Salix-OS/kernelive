--- aufs2-standalone/aufs2-kbuild.patch	2010-09-19 23:41:33.000000000 +0200
+++ aufs2-kbuild.patch	2010-10-23 14:53:58.441316946 +0200
@@ -1,4 +1,4 @@
-aufs2.1 kbuild patch for linux-2.6.35
+aufs2.1 kbuild patch for linux-2.6.36
 
 diff --git a/fs/Kconfig b/fs/Kconfig
 index 5f85b59..6ee7cf8 100644
@@ -25,11 +25,11 @@
 index 2fc8e14..3b766a7 100644
 --- a/include/linux/Kbuild
 +++ b/include/linux/Kbuild
-@@ -34,6 +34,7 @@ header-y += atmppp.h
+@@ -60,6 +60,7 @@
  header-y += atmsap.h
  header-y += atmsvc.h
- header-y += atm_zatm.h
+ header-y += audit.h
 +header-y += aufs_type.h
+ header-y += auto_fs.h
  header-y += auto_fs4.h
- header-y += ax25.h
- header-y += b1lli.h
+ header-y += auxvec.h
diff -ru fs/aufs/branch.c linux-2.6.36/fs/aufs/branch.c
--- fs/aufs/branch.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/branch.c	2010-10-27 20:07:24.378007988 +0200
@@ -322,7 +322,7 @@
 	 * cf. AUFS_MAX_NAMELEN in include/linux/aufs_type.h
 	 */
 	h_dentry = path->dentry;
-	err = vfs_statfs(h_dentry, &kst);
+	err = vfs_statfs(path, &kst);
 	if (unlikely(err))
 		goto out;
 	err = -EINVAL;
@@ -844,6 +844,10 @@
 	struct dentry *dentry;
 	struct inode *inode;
 	struct au_hfile *hfile;
+	struct list_head *list;
+#ifdef CONFIG_SMP
+	int cpu;
+#endif
 	const int step_bytes = 1024, /* memory allocation unit */
 		step_files = step_bytes / sizeof(*a);
 
@@ -855,9 +859,17 @@
 	if (unlikely(!a))
 		goto out;
 
+#ifdef CONFIG_SMP
+	cpu = smp_processor_id();
+	file->f_sb_list_cpu = cpu;
+	list = per_cpu_ptr(sb->s_files, cpu);
+#else
+	list = &sb->s_files;
+#endif
+
 	/* no need file_list_lock() since sbinfo is locked? defered? */
 	br_id = au_sbr_id(sb, bindex);
-	list_for_each_entry(file, &sb->s_files, f_u.fu_list) {
+	list_for_each_entry(file, list, f_u.fu_list) {
 		if (special_file(file->f_dentry->d_inode->i_mode))
 			continue;
 		dentry = file->f_dentry;
diff -ru fs/aufs/dir.c linux-2.6.36/fs/aufs/dir.c
--- fs/aufs/dir.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/dir.c	2010-10-27 20:07:24.396007219 +0200
@@ -209,12 +209,10 @@
 	aufs_bindex_t bindex, bend;
 
 	sb = file->f_dentry->d_sb;
+	au_plink_maint_leave(au_sbi(sb));
 	finfo = au_fi(file);
 	fidir = finfo->fi_hdir;
 	if (fidir) {
-		/* remove me from sb->s_files */
-		file_kill(file);
-
 		vdir_cache = fidir->fd_vdir_cache; /* lock-free */
 		if (vdir_cache)
 			au_vdir_free(vdir_cache);
diff -ru fs/aufs/f_op.c linux-2.6.36/fs/aufs/f_op.c
--- fs/aufs/f_op.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/f_op.c	2010-10-27 20:07:24.402007638 +0200
@@ -78,13 +78,11 @@
 	struct au_finfo *finfo;
 	aufs_bindex_t bindex;
 
+	au_plink_maint_leave(au_sbi(file->f_dentry->d_sb));
 	finfo = au_fi(file);
 	bindex = finfo->fi_btop;
-	if (bindex >= 0) {
-		/* remove me from sb->s_files */
-		file_kill(file);
+	if (bindex >= 0)
 		au_set_h_fptr(file, bindex, NULL);
-	}
 
 	au_finfo_fin(file);
 	return 0;
diff -ru fs/aufs/file.c linux-2.6.36/fs/aufs/file.c
--- fs/aufs/file.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/file.c	2010-10-27 20:07:24.405007149 +0200
@@ -95,7 +95,7 @@
 			goto out_br;
 		}
 	}
-	fsnotify_open(h_dentry);
+	fsnotify_open(h_file);
 	goto out; /* success */
 
 out_br:
diff -ru fs/aufs/hfsnotify.c linux-2.6.36/fs/aufs/hfsnotify.c
--- fs/aufs/hfsnotify.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/hfsnotify.c	2010-10-27 20:07:24.409008476 +0200
@@ -27,11 +27,11 @@
 				 | FS_CREATE | FS_EVENT_ON_CHILD);
 static struct fsnotify_group *au_hfsn_group;
 
-static void au_hfsn_free_mark(struct fsnotify_mark_entry *entry)
+static void au_hfsn_free_mark(struct fsnotify_mark *mark)
 {
 #if 0
-	struct au_hnotify *hn = container_of(entry, struct au_hnotify,
-					     hn_entry);
+	struct au_hnotify *hn = container_of(mark, struct au_hnotify,
+					     hn_mark);
 	au_cache_free_hnotify(hn);
 #endif
 	AuDbg("here\n");
@@ -39,39 +39,40 @@
 
 static int au_hfsn_alloc(struct au_hnotify *hn, struct inode *h_inode)
 {
-	struct fsnotify_mark_entry *entry;
+	struct fsnotify_mark *mark;
 
-	entry = &hn->hn_entry;
-	fsnotify_init_mark(entry, au_hfsn_free_mark);
-	entry->mask = AuHfsnMask;
-	return fsnotify_add_mark(entry, au_hfsn_group, h_inode);
+	mark = &hn->hn_mark;
+	fsnotify_init_mark(mark, au_hfsn_free_mark);
+	mark->mask = AuHfsnMask;
+	//return fsnotify_add_mark(mark, au_hfsn_group, h_inode); // mnt, allow_dups
+	return fsnotify_add_mark(mark, au_hfsn_group, h_inode, NULL, 1);
 }
 
 static void au_hfsn_free(struct au_hnotify *hn)
 {
-	struct fsnotify_mark_entry *entry;
+	struct fsnotify_mark *mark;
 
-	entry = &hn->hn_entry;
-	fsnotify_destroy_mark_by_entry(entry);
-	fsnotify_put_mark(entry);
+	mark = &hn->hn_mark;
+	fsnotify_destroy_mark(mark);
+	fsnotify_put_mark(mark);
 }
 
 /* ---------------------------------------------------------------------- */
 
 static void au_hfsn_ctl(struct au_hinode *hinode, int do_set)
 {
-	struct fsnotify_mark_entry *entry;
+	struct fsnotify_mark *mark;
 
-	entry = &hinode->hi_notify->hn_entry;
-	spin_lock(&entry->lock);
+	mark = &hinode->hi_notify->hn_mark;
+	spin_lock(&mark->lock);
 	if (do_set) {
-		AuDebugOn(entry->mask & AuHfsnMask);
-		entry->mask |= AuHfsnMask;
+		AuDebugOn(mark->mask & AuHfsnMask);
+		mark->mask |= AuHfsnMask;
 	} else {
-		AuDebugOn(!(entry->mask & AuHfsnMask));
-		entry->mask &= ~AuHfsnMask;
+		AuDebugOn(!(mark->mask & AuHfsnMask));
+		mark->mask &= ~AuHfsnMask;
 	}
-	spin_unlock(&entry->lock);
+	spin_unlock(&mark->lock);
 	/* fsnotify_recalc_inode_mask(hinode->hi_inode); */
 }
 
@@ -113,13 +114,14 @@
 /* ---------------------------------------------------------------------- */
 
 static int au_hfsn_handle_event(struct fsnotify_group *group,
+				struct fsnotify_mark *inode_mark,
+				struct fsnotify_mark *vfsmount_mark,
 				struct fsnotify_event *event)
 {
 	int err;
 	struct au_hnotify *hnotify;
 	struct inode *h_dir, *h_inode;
 	__u32 mask;
-	struct fsnotify_mark_entry *entry;
 	struct qstr h_child_qstr = {
 		.name	= event->file_name,
 		.len	= event->name_len
@@ -128,10 +130,10 @@
 	AuDebugOn(event->data_type != FSNOTIFY_EVENT_INODE);
 
 	err = 0;
-	/* if IN_UNMOUNT happens, there must be another bug */
+	/* if FS_UNMOUNT happens, there must be another bug */
 	mask = event->mask;
 	AuDebugOn(mask & FS_UNMOUNT);
-	if (mask & (IN_IGNORED | IN_UNMOUNT))
+	if (mask & (FS_IN_IGNORED | FS_UNMOUNT))
 		goto out;
 
 	h_dir = event->to_tell;
@@ -148,38 +150,26 @@
 	au_debug(0);
 #endif
 
-	spin_lock(&h_dir->i_lock);
-	entry = fsnotify_find_mark_entry(group, h_dir);
-	spin_unlock(&h_dir->i_lock);
-	if (entry) {
-		hnotify = container_of(entry, struct au_hnotify, hn_entry);
-		err = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);
-		fsnotify_put_mark(entry);
-	}
+	AuDebugOn(!inode_mark);
+	hnotify = container_of(inode_mark, struct au_hnotify, hn_mark);
+	err = au_hnotify(h_dir, hnotify, mask, &h_child_qstr, h_inode);
 
 out:
 	return err;
 }
 
-/* copied from linux/fs/notify/inotify/inotify_fsnotiry.c */
+/* copied from linux/fs/notify/inotify/inotify_fsnotify.c */
 /* it should be exported to modules */
 static bool au_hfsn_should_send_event(struct fsnotify_group *group,
-				      struct inode *h_inode, __u32 mask)
+				      struct inode *h_inode,
+				      struct fsnotify_mark *inode_mark,
+				      struct fsnotify_mark *vfsmount_mark,
+				      __u32 mask, void *data, int data_type)
 {
-	struct fsnotify_mark_entry *entry;
 	bool send;
 
-	spin_lock(&h_inode->i_lock);
-	entry = fsnotify_find_mark_entry(group, h_inode);
-	spin_unlock(&h_inode->i_lock);
-	if (!entry)
-		return false;
-
 	mask = (mask & ~FS_EVENT_ON_CHILD);
-	send = (entry->mask & mask);
-
-	/* find took a reference */
-	fsnotify_put_mark(entry);
+	send = (inode_mark->mask & mask);
 
 	return send;
 }
@@ -194,21 +184,12 @@
 static int __init au_hfsn_init(void)
 {
 	int err;
-	unsigned int gn;
-	const unsigned int gn_max = 10;
-
-	gn = 0;
-	for (gn = 0; gn < gn_max; gn++) {
-		au_hfsn_group = fsnotify_obtain_group(gn, AuHfsnMask,
-						      &au_hfsn_ops);
-		if (au_hfsn_group != ERR_PTR(-EEXIST))
-			break;
-	}
 
 	err = 0;
+	au_hfsn_group = fsnotify_alloc_group(&au_hfsn_ops);
 	if (IS_ERR(au_hfsn_group)) {
-		pr_err("fsnotify_obtain_group() failed %u times\n", gn_max);
 		err = PTR_ERR(au_hfsn_group);
+		pr_err("fsnotify_alloc_group() failed, %d\n", err);
 	}
 
 	AuTraceErr(err);
diff -ru fs/aufs/i_op.c linux-2.6.36/fs/aufs/i_op.c
--- fs/aufs/i_op.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/i_op.c	2010-10-27 20:07:24.415008127 +0200
@@ -666,12 +666,9 @@
 	if (ia->ia_valid & ATTR_SIZE) {
 		struct file *f;
 
-		if (ia->ia_size < i_size_read(inode)) {
+		if (ia->ia_size < i_size_read(inode))
 			/* unmap only */
-			err = simple_setsize(inode, ia->ia_size);
-			if (unlikely(err))
-				goto out_unlock;
-		}
+			truncate_setsize(inode, ia->ia_size);
 
 		f = NULL;
 		if (ia->ia_valid & ATTR_FILE)
diff -ru fs/aufs/inode.h linux-2.6.36/fs/aufs/inode.h
--- fs/aufs/inode.h	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/inode.h	2010-10-27 20:07:24.424007848 +0200
@@ -35,7 +35,7 @@
 struct au_hnotify {
 #ifdef CONFIG_AUFS_HNOTIFY
 #ifdef CONFIG_AUFS_HFSNOTIFY
-	struct fsnotify_mark_entry	hn_entry;
+	struct fsnotify_mark	hn_mark;
 #else
 	struct inotify_watch		hn_watch;
 #endif
diff -ru fs/aufs/super.c linux-2.6.36/fs/aufs/super.c
--- fs/aufs/super.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/super.c	2010-10-27 20:07:24.442007359 +0200
@@ -298,7 +298,7 @@
 	u64 blocks, bfree, bavail, files, ffree;
 	aufs_bindex_t bend, bindex, i;
 	unsigned char shared;
-	struct vfsmount *h_mnt;
+	struct path h_path;
 	struct super_block *h_sb;
 
 	blocks = 0;
@@ -310,8 +310,8 @@
 	err = 0;
 	bend = au_sbend(sb);
 	for (bindex = bend; bindex >= 0; bindex--) {
-		h_mnt = au_sbr_mnt(sb, bindex);
-		h_sb = h_mnt->mnt_sb;
+		h_path.mnt = au_sbr_mnt(sb, bindex);
+		h_sb = h_path.mnt->mnt_sb;
 		shared = 0;
 		for (i = bindex + 1; !shared && i <= bend; i++)
 			shared = (au_sbr_sb(sb, i) == h_sb);
@@ -319,7 +319,8 @@
 			continue;
 
 		/* sb->s_root for NFS is unreliable */
-		err = vfs_statfs(h_mnt->mnt_root, buf);
+		h_path.dentry = h_path.mnt->mnt_root;
+		err = vfs_statfs(&h_path, buf);
 		if (unlikely(err))
 			goto out;
 
@@ -343,15 +344,18 @@
 static int aufs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int err;
+	struct path h_path;
 	struct super_block *sb;
 
 	/* lock free root dinfo */
 	sb = dentry->d_sb;
 	si_noflush_read_lock(sb);
-	if (!au_opt_test(au_mntflags(sb), SUM))
+	if (!au_opt_test(au_mntflags(sb), SUM)) {
 		/* sb->s_root for NFS is unreliable */
-		err = vfs_statfs(au_sbr_mnt(sb, 0)->mnt_root, buf);
-	else
+		h_path.mnt = au_sbr_mnt(sb, 0);
+		h_path.dentry = h_path.mnt->mnt_root;
+		err = vfs_statfs(&h_path, buf);
+	} else
 		err = au_statfs_sum(sb, buf);
 	si_read_unlock(sb);
 
diff -ru fs/aufs/sysfs.c linux-2.6.36/fs/aufs/sysfs.c
--- fs/aufs/sysfs.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/sysfs.c	2010-10-27 20:07:24.446008197 +0200
@@ -203,7 +203,6 @@
 	sysfs_attr_init(attr);
 	attr->name = br->br_name;
 	attr->mode = S_IRUGO;
-	attr->owner = THIS_MODULE;
 }
 
 void sysaufs_brs_del(struct super_block *sb, aufs_bindex_t bindex)
diff -ru fs/aufs/vfsub.c linux-2.6.36/fs/aufs/vfsub.c
--- fs/aufs/vfsub.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/vfsub.c	2010-10-27 20:07:24.450008127 +0200
@@ -573,7 +573,7 @@
 
 	err = locks_verify_truncate(h_inode, h_file, length);
 	if (!err)
-		err = security_path_truncate(h_path, length, attr);
+		err = security_path_truncate(h_path);
 	if (!err)
 		err = do_truncate(h_path->dentry, length, attr, h_file);
 
diff -ru fs/aufs/wbr_policy.c linux-2.6.36/fs/aufs/wbr_policy.c
--- fs/aufs/wbr_policy.c	2010-09-19 23:41:33.000000000 +0200
+++ linux-2.6.36/fs/aufs/wbr_policy.c	2010-10-27 20:07:24.453008057 +0200
@@ -407,6 +407,7 @@
 	aufs_bindex_t bindex, bend;
 	int err;
 	unsigned long long b, bavail;
+	struct path h_path;
 	/* reduce the stack usage */
 	struct kstatfs *st;
 
@@ -429,7 +430,9 @@
 			continue;
 
 		/* sb->s_root for NFS is unreliable */
-		err = vfs_statfs(br->br_mnt->mnt_root, st);
+		h_path.mnt = br->br_mnt;
+		h_path.dentry = h_path.mnt->mnt_root;
+		err = vfs_statfs(&h_path, st);
 		if (unlikely(err)) {
 			AuWarn1("failed statfs, b%d, %d\n", bindex, err);
 			continue;
Seulement dans linux-2.6.36/fs: inode.c.orig
Seulement dans linux-2.6.36/fs: namei.c.orig
Seulement dans linux-2.6.36/fs: namespace.c.orig
Seulement dans linux-2.6.36/fs: splice.c.orig
Seulement dans linux-2.6.36/fs: squashfs
